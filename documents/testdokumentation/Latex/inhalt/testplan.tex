% Kapitel 2 mit den entsprechenden Unterkapiteln
% Die Unterkapitel können auch in separaten Dateien stehen,
% die dann mit dem \include-Befehl eingebunden werden.
%----------------------------------------------------------------------------

\chapter{Testplan}

Der Testplan ist das zentrale Dokument der Qualitätssicherung und wird daher
frühzeitig erstellt. Hier wird Umfang und Vorgehensweise der Qualitätssicherung
beschrieben. Außerdem werden Testgegenstände und deren zu testenden
Eigenschaften bzw. Funktionen identifiziert. Ferner werden die
durchzuführenden Maßnahmen und die dafür verantwortlichen Personen definiert.
Falls erforderlich sollte hier auch auf allgemeine Risiken eingegangen werden.

\section{Zu testende Komponenten}
Der Achterbahnsimulator ist eine Einzelplatzanwendung. Das fertige Produkt wird als monolitisches System abgenommen und ist deswegen im strengen Sinne keine verteile Anwendung. Da jedoch zu den Anforderungen an den Simulator das Einlesen der Achterbahndaten aus dem Editor zählt, muss dieses Zusammenspiel geprüft werden.

Der Achterbahnsimulator setzt sich gemäß Entwurf aus verschiedenen Komponenten zusammen, deren Aufteilung bei der Implementierung zur Beibehaltung der Konhärenz inenrhalb der Komponenten und Vermeidung von zwischen den Komponenten beizubehalten war.
Entsprechend können diese Komponenten getrennt geprüft werden. 

Da die Software eine 3D-Anzeige beeinhaltet ist es vor dem Test sicherzustellen, dass die Grafikkarte entsprechend inklusive 3D-Beschleunigung eingerichtet ist.
Die Software kann online (im Repository) oder lokal auf Festplatte oder CD vorliegen. In jedem Fall ist dafür Sorge zu tragen, dass die Software die Möglichkeit hat in dem lokalen Pfad Dateien anzulegen.

\section{Zu testende Funktionen}
% Dieser Punkt beinhaltet alle Eigenschaften bzw. Funktionen und deren
% Kombinationen, die zu testen sind.
% 
% Sämtliche Funktionalitäten, die getestet werden sollen, werden hier aufgeführt.
% Dabei sind auf die vorangegangenen Dokumentationen zu referenzieren
% (Pflichtenheft, Grob- und Fein-entwurf) und die dortigen Funktions-IDs zu
% verwenden!\\ Beispiel: /F100/ : Benutzer Login
Im folgenden findet sich eine Liste über die Funktionen des Programms die zu testen sind. 

/F100/ : Spezifikation einlesen\\
\\
/F200/ : Starten/Stoppen der Simulation\\
\\
/F300/ : Pausieren der Simulation\\
\\
/F500/ : Einstellungen ändern\\
\\
/F520/ : Simulationsparameter ändern\\
\\
/F530/ : Grafische Einstellungen ändern\\
\\
/F531/ : Neuanordnung (Interface)\\
\\
/F532/ : Ein-/Ausblenden von Beschleunigungsdaten\\
\\
/F533o/ : Kameraperspektive ändern\\
\\
/F1000/ : Warnung vor zu hoher Beschleunigung\\
\\
/F1100/ : Erkennung von Veränderungen an der Ursprungsdatei



HIER ERSTMLA NUR DIE MUSS KRITERIEN... NOCH NICHT FERTIG!!!

\section{Nicht zu testende Funktionen}
(optional; auszufüllen, falls es Funktionen gibt, die nicht getestet werden
sollen)\\

Hier werden alle Eigenschaften bzw. Funktionen und Funktionskombinationen
aufgelistet, die nicht getestet werden.
\textbf{ Es sollte begründet werden, warum diese nicht getestet werden.} Es
versteht sich von selber, dass alle Muss-Funktionalitäten des Pflichtenheftes
(Abschnitt 1.1) getestet werden müssen.

\section{Vorgehen}

Während sich für den mathematisch-physikalischen Kern der Anwendung eine Prüfung mit automatisierten Tests umsetzen lässt, müssen diese für die visuellen Komponenten der GUI und 3D-Grafik weitestgehend händische vorgenommen werden.

Für die Durchführung der JUnit-Testfälle wurde ein \textbf{ant}-Task in der \textbf{build.xml} angelegt, dessen Prüfprotokolle als XML-Dateien generiert und nachbearbeitet werden können.

Für die Prüfung des 3D-Grafikmoduls wird eine reduzierte Variante des Simulators kompiliert und ausgeführt. Auch dafür steht ein passender \textbf{ant}-Task zur Verfügung.

Beispiel für Vorgehen (unvollständige Liste):\\
a) Komponenten- und Integrationstests\\
Klassen werden mit JUnit-Testfällen geprüft. Vor Beginn der Implementierung
werden bereits Blackbox-Testfälle erstellt, die dann begleitend zur
Implementierung genutzt werden ("`Test first"'). Nach Abschluss der
Implementierung einer Komponente wird diese dann durch Whitebox-Tests
geprüft.\\
Der Integrationstest der Klassen und Komponenten erfolgt nach dem
Bottom-Up-Prinzip. Anfangs muss die Integration der Datenbankanbindung und den
entsprechenden Data-Access-Objects (DAO) geprüft werden, da das Mapping der
Datenbank auf Objekte die unterste Schicht des Projektes bildet. Dieser
Testabschnitt wird durch die Schnittstellentests abgedeckt.
Die Komponenten werden damit unter Berücksichtigung ihrer Abhängigkeiten
konkret in folgender Reihenfolge integriert: \ldots\\
(Hier kommt das konkrete Vorgehen bei der Integration: Welche Klassen werden
zusammen getestet, welche kommen dann dazu etc. Das kann man z.B. auch schön in
Form eines Baumes aufzeigen.)
b) Funktionstests\\
Die Anwendungsfälle aus der Anforderungsspezifikation werden über das
Web-Interface geprüft. Mindestanforderung hierfür ist es, jeden Fall einmal auf
seine korrekte Funktionalität zu testen.\\
c) \ldots

\section{Testumgebung}
Die genutzte Testumgebung(en) bitte hier angeben und kurz beschreiben.\\
Beispiel: JUnit Testsuite, lokal installierter Web Application Server, \ldots

